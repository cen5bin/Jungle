#!/usr/bin/python
# coding=utf-8

import sys, os


class Jungle:
    def __init__(self):
        self.root = os.path.split(os.path.realpath(__file__))[0]
        self.scriptRoot = os.path.join(self.root, 'script')
        self.resourcesRoot = os.path.join(self.root, 'resources')
        self.projectTemplateRoot = os.path.join(self.resourcesRoot, 'project_template')
        self.configureRoot = os.path.join(self.resourcesRoot, 'configure')
        self.cmd_list = [
            ('-h, --help', '', self.__showHelp, '使用帮助'),
            ('maven, mvn', '<name> [path]', self.__newMavenProject, '\n\t创建maven项目，必须指定项目名称，不指定路径默认就是当前路径'),
            ('cpp', '<name> [path]', self.__newSimpleCMakeProject, '创建基础CMake项目'),
            ('new', '<kind> <name> [path]', self.__newFile, '\n\t创建文件, kind:c,cc,cpp,cclass,cheader'),
            ('vim', '', self.__configVim, 'vim配置'),
            ('idea', '', self.__configIDEA, 'idea配置'),
            ('tmux', '', self.__configTmux, 'tmux配置'),
        ]

    def __showHelp(self):
        title = '-' * 30 + ' Jungle ' + '-' * 30
        print title
        print '用法: jungle command [args]\n'
        for cmd in self.cmd_list:
            print cmd[0] + ' ' + cmd[1] + ': ' + cmd[3]
        print '-' * len(title)

    def __newMavenProject(self, name, path='.'):
        print '创建maven工程...............'
        print '项目名称: %s' % (name)
        print '项目路径: %s' % (os.path.realpath(path))
        os.system('sh %s %s %s %s' % (os.path.join(self.scriptRoot, 'new_maven.sh'), os.path.join(self.projectTemplateRoot, 'SimpleMaven'), path, name))

    def __newSimpleCMakeProject(self, name, path='.'):
        print '创建Simple CMake工程...............'
        print '项目名称: %s' % (name)
        print '项目路径: %s' % (os.path.realpath(path))
        os.system('sh %s %s %s %s' % (os.path.join(self.scriptRoot, 'new_simple_cmake.sh'), os.path.join(self.projectTemplateRoot, 'SimpleCMake'), path, name))

    def __newFile(self, kind, name, path='.'):
        if kind in ['cpp', 'cc', 'c', 'cheader', 'cclass']:
            print '创建%s文件...............' % kind
            if kind not in ['cheader', 'cclass']:
                print '文件名称: %s.h %s.%s' % (name, name, kind)
            elif kind == 'cheader':
                print '文件名称: %s.h' % (name)
            elif kind == 'cclass':
                print '文件名称: %s.h %s.cc' % (name, name)
            print '文件路径: %s' % (os.path.realpath(path))
            filename = os.path.join(path, name)
            f = open(filename + '.h', 'w')
            f.write('#ifndef __%s_H\n' % name.upper())
            f.write('#define __%s_H\n' % name.upper())
            if kind == 'cclass':
                f.write('class %s {\n\tpublic:\n\t\t%s(){}\n\t\tvirtual ~%s(){}\n\n\tprivate:\n\n};\n\n' % (name, name, name))
                pass
            f.write('#endif')
            f.close()
            if kind != 'cheader':
                kind = 'cc' if kind == 'cclass' else kind
                f = open(filename + ('.%s' % kind), 'w')
                f.write('#include "%s.h"\n\n' % name)
                f.close()

    def __configVim(self):
        print '配置vim......................'
        os.system('sh %s %s' % (os.path.join(self.scriptRoot, 'config_vim.sh'), os.path.join(self.configureRoot, 'vim')))
        
    def __configIDEA(self):
        print 'idea的配置在%s中，请在软件中导入' % (os.path.join(self.configureRoot, 'idea'))

    def __configTmux(self):
        os.system('cp %s ~/.tmux.conf' % (os.path.join(os.path.join(self.configureRoot, 'tmux'), 'tmux.conf')))

    def __invalid(self, cmd, argv):
        if len(cmd) == 0:
            return True if len(argv) == 2 else False
        args = [x.strip() for x in cmd.split(' ')]
        ret = len(args)
        if len(argv) - 2 > ret:
            return False
        for i in xrange(1, len(args)+1):
            if args[-i].startswith('[') and args[-i].endswith(']'):
                ret -= 1
            else:
                break
        return True if len(argv) - 2 >= ret else False
    
    def run(self, argv):
        if len(argv) == 1:
            self.__showHelp()
            return
        for cmd in self.cmd_list:
            #print argv[1]
            if self.__invalid(cmd[1], argv) and argv[1] in [x.strip() for x in cmd[0].split(',')]:
                cmd[2](*argv[2:])
                return
        self.__showHelp()


if __name__ == '__main__':
    jungle = Jungle()
    jungle.run(sys.argv)
